# [0033. Node.js 的工作原理](https://github.com/Tdahuyou/TNotes.nodejs/tree/main/notes/0033.%20Node.js%20%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86)

<!-- region:toc -->

- [1. 📒 概述](#1--概述)

<!-- endregion:toc -->

## 1. 📒 概述

- 事件驱动
  - Node.js 采用一种独特的事件驱动思想，将 I/O 操作作为事件响应，而不是阻塞操作，从而实现了事件函数的快速执行与错误处理。
  - 由于 Node.js 能够采用异步非阻塞的方式访问文件系统、数据库、网络等外部资源，因此，它能够高效地处理海量的并发请求，极大地提高了应用程序的吞吐量。
- 单线程
  - Node.js 采用单线程模型，只需要轻量级的线程即可处理大量的请求。
  - 与多线程模型相比，这种模型消除了线程之间的竞争，使得程序的稳定性大幅度提升。
  - 在 Node.js 的单线程模型中，所有的 I/O 操作都被放在事件队列中，一旦事件出现，Node.js 就会依次处理它们。
  - 事实上，大多数网站的服务器端都不会做太多的计算，它们接收到请求以后，把请求交给其他服务来处理（如读取数据库），然后等待结果返回，再把结果发给客户端。
  - 因此，Node.js 针对这一事实采用了单线程模型来处理，它不会为每个接入请求分配一个线程，而是用一个主线程处理所有的请求，然后对 I/O 操作进行异步处理，避开了创建、销毁线程以及在线程间切换所需的开销和复杂性。
- 非阻塞 I/O
  - 在传统的 I/O 操作（例如，读取或写入磁盘文件，或者对远程服务器进行网络调用）中，当数据读取或写入操作发生时，程序会被阻塞，等数据读取或写入操作完成后才能进入下一步操作。
  - 但是，在 Node.js 中，所有的 I/O 操作都是非阻塞的，当某个 I/O 操作发生时，不是等待其执行完成才能进入下一步操作，而是直接回调相应的函数，从而实现了对外部资源的高效访问。
- 事件循环
  - ![图 0](https://cdn.jsdelivr.net/gh/Tdahuyou/imgs@main/2025-04-04-10-33-30.png)
  - ![图 1](https://cdn.jsdelivr.net/gh/Tdahuyou/imgs@main/2025-04-04-10-41-39.png)
  - Node.js 采用了一种特殊的设计方式 —— 事件循环，它在工作线程池中维护一个任务队列，当接到请求后，将该请求作为一个事件放入这个队列中，然后继续接收其他请求，同时，Node.js 程序会不断地从工作队列中获取要执行的事件，并通过事件循环流程对其进行处理。
  - 事件循环的主要工作阶段：
    - 计时器：处理由 setTimeout() 和 setInterval() 设置的回调。
    - 回调：运行挂起的回调函数。
    - 轮询：检索传入的 I/O 事件并运行与 I/O 相关的回调。
    - 检查：完成轮询后立即运行回调。
    - 关闭回调：关闭事件和回调。
  - 无论是在 Linux 平台还是 Windows 平台上，Node.js 内部都是通过线程池来完成异步 I/O 操作的，而 libuv 针对不同平台的差异性实现了统一调用，因此 Node.js 的单线程仅仅是指 JavaScript 运行在单线程中，而并非 Node.js 是单线程的。
- 模块化设计
  - 在 Node.js 中，采用了一种模块化的设计方式，按照功能模块将代码拆分成多个文件，使用 require 函数引入，从而提高了代码的复用率，同时也增强了代码的可维护性。
  - 另外，Node.js 提供了许多内置模块，如 http 模块、fs 模块等，能够帮助开发者快速搭建 Web 应用服务。
