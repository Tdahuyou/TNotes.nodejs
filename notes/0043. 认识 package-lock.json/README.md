# [0043. 认识 package-lock.json](https://github.com/Tdahuyou/TNotes.nodejs/tree/main/notes/0043.%20%E8%AE%A4%E8%AF%86%20package-lock.json)

<!-- region:toc -->

- [1. 📝 概述](#1--概述)
- [2. 🤔 `package-lock.json` 文件是什么？](#2--package-lockjson-文件是什么)
- [3. 🤔 `package-lock.json` 的核心作用是？](#3--package-lockjson-的核心作用是)
- [4. 🤔 在开发过程中，是否需要关注 `package-lock.json` 文件中的内容？](#4--在开发过程中是否需要关注-package-lockjson-文件中的内容)
- [5. 🤔 如果没有 `package-lock.json`，直接使用 `package.json` 中的语义化版本信息来定位依赖包，会有什么问题？](#5--如果没有-package-lockjson直接使用-packagejson-中的语义化版本信息来定位依赖包会有什么问题)
- [6. 🤔 如果直接将整个 `node_modules` 推送到仓库中，那是不是就没必要用 `package-lock.json` 了呢？](#6--如果直接将整个-node_modules-推送到仓库中那是不是就没必要用-package-lockjson-了呢)
  - [6.1. 直接推送 `node_modules` 弊端](#61-直接推送-node_modules-弊端)
  - [6.2. 使用 `package-lock.json` 的优势](#62-使用-package-lockjson-的优势)
  - [6.3. 最佳实践](#63-最佳实践)
- [7. 🤔 `package-lock.json` 通常无需手动维护，那么它在什么情况下会被更新呢？](#7--package-lockjson-通常无需手动维护那么它在什么情况下会被更新呢)
  - [7.1. `package-lock.json` 自动更新的情况](#71-package-lockjson-自动更新的情况)
  - [7.2. 情况 A：首次安装](#72-情况-a首次安装)
  - [7.3. 情况 B：`package.json` 发生了变化](#73-情况-bpackagejson-发生了变化)
  - [7.4. 最佳实践](#74-最佳实践)
- [8. 🤔 `package-lock.json` 是如何实现“锁定具体版本”的？](#8--package-lockjson-是如何实现锁定具体版本的)
  - [8.1. 关键字段解析：`package-lock.json` 如何锁定](#81-关键字段解析package-lockjson-如何锁定)
  - [8.2. npm 安装时如何使用 `package-lock.json`](#82-npm-安装时如何使用-package-lockjson)
  - [8.3. 举个例子：为什么需要锁定？](#83-举个例子为什么需要锁定)
  - [8.4. 小结](#84-小结)
- [9. 🤔 `npm`、`package.json`、`package-lock.json`、`node_modules` 四者之间的关系是？](#9--npmpackagejsonpackage-lockjsonnode_modules-四者之间的关系是)
- [10. 📒 `package-lock.json` 文件结构](#10--package-lockjson-文件结构)
- [11. 📒 `package-lock.json` 的自动生成、更新、重置](#11--package-lockjson-的自动生成更新重置)
- [12. 🔗 References](#12--references)

<!-- endregion:toc -->

## 1. 📝 概述

- 认识 `package-lock.json` 文件
- 了解 `package-lock.json` 是如何实现版本锁定的

## 2. 🤔 `package-lock.json` 文件是什么？

- `package-lock.json` 是 npm 自动生成的文件，主要作用是 **锁定依赖的具体版本**，确保在不同环境中安装的依赖完全一致，**避免因版本不一致导致的依赖问题**。
- 在 npm5 以上的版本中，引入了 `package-lock.json` 文件，该文件旨在跟踪被安装的每个软件包的确切版本，以便项目可以以相同的方式被 100% 复制（即使软件包的维护者更新了软件包）​。
- 当运行 `npm install` 时，`package-lock.json` 会被更新以记录当前安装的依赖版本。

## 3. 🤔 `package-lock.json` 的核心作用是？

| 作用 | 描述 |
| --- | --- |
| **锁定依赖的具体版本** | 明确记录每个依赖及其子依赖的确切版本号。 |
| **生成一致的依赖树** | 无论在哪台机器上运行 `npm install`，都会生成相同的依赖结构。 |
| **提高安装效率** | 通过缓存和锁定版本，减少重复下载和解析依赖的时间。 |

## 4. 🤔 在开发过程中，是否需要关注 `package-lock.json` 文件中的内容？

- **不需要**，你在安装依赖的时候 `package-lock.json` 文件中的内容会自动更新。
- 在开发过程中通常无需关注 `package-lock.json` 的内容，但在以下场景中查看会有所帮助：
  - 排查依赖版本问题。
  - 优化依赖结构。
  - 进行安全审计。
    - 使用工具（如 `npm audit`）检查依赖的安全性时，`package-lock.json` 提供了所有依赖的完整列表和版本信息。
    - 通过查看文件内容，可以快速定位存在安全漏洞的依赖及其具体版本。
- **最佳实践**：
  - 始终将 `package-lock.json` 提交到版本控制系统中。
  - 避免手动修改 `package-lock.json`，通过 `npm install` 或 `npm update` 更新依赖。
  - 定期清理无用依赖，并使用工具（如 `npm audit`）检查依赖版本的安全性。

## 5. 🤔 如果没有 `package-lock.json`，直接使用 `package.json` 中的语义化版本信息来定位依赖包，会有什么问题？

- `package-lock.json` 文件的出现解决了 `package.json` 一直存在的特殊问题，在 `package.json` 中，可以使用 semver（语义化版本）表示法设置要升级到的版本（补丁版本或次版本）​。
- 在 Node.js 项目中，依赖管理是通过 `package.json` 文件完成的。然而，`package.json` 中的依赖版本通常使用语义化版本范围（如 `^1.2.3` 或 `~1.2.3`），这会导致在不同环境中安装的依赖版本可能不同。例如：
  - 开发者 A 安装了 `1.2.5`。
  - 开发者 B 安装了 `1.2.8`。
  - 部署到生产环境时安装了 `1.2.10`。
- 这种差异可能导致 —— **行为表现不一致** 的问题。
  - **开发环境与生产环境不一致**：某些功能在开发环境中正常，但在生产环境中出现问题。
  - **团队协作问题**：团队成员之间使用的依赖版本不同，导致代码行为不一致。
- 为了解决这些问题，npm 引入了 `package-lock.json` 文件，确保在不同环境中安装的依赖完全一致，**避免因版本不一致导致的问题**。

## 6. 🤔 如果直接将整个 `node_modules` 推送到仓库中，那是不是就没必要用 `package-lock.json` 了呢？

### 6.1. 直接推送 `node_modules` 弊端

- 即使直接提交 `node_modules` 在某些情况下，可以解决依赖一致性问题，但由于其体积庞大、缺乏灵活性、难以维护等问题，因此可以认为这种做法是不可行的。
- **`node_modules` 文件夹体积庞大**
  - `node_modules` 文件夹通常包含大量文件和子依赖，大小可能达到数百 MB 或更多。
  - 推送到代码仓库会导致仓库体积迅速膨胀。
  - 拉取代码时耗时增加，尤其对大型项目或分布式团队不友好。
  - 增加存储成本（如 GitLab、GitHub 等平台对存储空间有限制）。
- **缺乏灵活性**
  - 不同操作系统（如 Windows、macOS、Linux）可能对某些依赖有特定的编译需求。
  - 某些依赖需要根据目标环境动态生成二进制文件（如 `node-gyp` 编译的模块）。
  - 比如你在 Windows 环境下直推送了 `node_modules`，但是在你同事的 macOS 设备上拉下来是没法正常工作的。
- **难以维护**
  - 当依赖更新时，开发者需要手动删除旧的 `node_modules` 文件夹并重新安装依赖，再提交到仓库。
  - 团队成员频繁更新依赖会引发大量冲突和冗余提交。

### 6.2. 使用 `package-lock.json` 的优势

- 记录依赖树的完整信息，包括每个依赖的具体版本号、下载地址和校验值（`integrity` 字段）。
- 能够在不同环境中精确还原依赖树，无需提交庞大的 `node_modules` 文件夹。
- 开发者只需运行 `npm install`，即可根据锁定的版本信息自动安装一致的依赖。

### 6.3. 最佳实践

- 不要提交 `node_modules`，将其添加到 `.gitignore` 文件中。
- 始终提交 `package-lock.json`，确保依赖一致性。
- 使用 CI/CD 工具，通过 `npm ci` 命令（基于 `package-lock.json` 快速安装依赖）确保生产环境与开发环境一致。
- 使用 `package-lock.json` 文件结合 `.gitignore` 忽略 `node_modules` 是更高效、更灵活的最佳实践。

## 7. 🤔 `package-lock.json` 通常无需手动维护，那么它在什么情况下会被更新呢？

### 7.1. `package-lock.json` 自动更新的情况

- **`package-lock.json` 是由 npm 自动（自动生成和维护）的文件**，开发者通常不需要手动编辑它。
- npm 会根据依赖安装和变更操作自动更新这个文件。
- 当你首次运行 `npm install` 时，如果项目中没有 `package-lock.json`，npm 会：
  1. 根据 `package.json` 解析依赖
  2. 安装对应的包到 `node_modules`
  3. 自动生成 `package-lock.json` 文件，记录完整的依赖树和版本快照
- 从 **npm 5.0+** 开始（2017 年发布），`package-lock.json` 默认启用并推荐提交到版本控制。
- 以下是常见的触发 `package-lock.json` 更新的场景：
  1. **首次运行 `npm install`**
  2. **依赖变更**

### 7.2. 情况 A：首次安装

```bash
npm install
```

- 如果没有 `package-lock.json`，npm 会生成一个新的。
- 如果有，但 `node_modules` 缺失或不完整，npm 会根据 lock 文件安装，并可能微调 lock 文件（如补全字段）。

### 7.3. 情况 B：`package.json` 发生了变化

```bash
# 比如你修改了某个依赖版本：
# "lodash": "^4.17.0" → "lodash": "^4.17.20"
# 再运行：
npm install
```

- 此时 npm 会重新解析依赖，安装新版本，并 **更新 `package-lock.json`**。
- 除了更新包之外，安装新包、删除包等操作，都会导致依赖发生变化，这些时候都会更新 lock 文件。

### 7.4. 最佳实践

- 修改 `package.json` 中的依赖项之后，一定要运行 `npm install` 来同步 `package-lock.json`。
- **不要手动编辑** `package-lock.json`
- 提交代码时，确认 `package.json` 和 `package-lock.json` 一起提交
- 团队使用相同版本的 npm（不同版本可能生成格式不同的 lock 文件）

## 8. 🤔 `package-lock.json` 是如何实现“锁定具体版本”的？

### 8.1. 关键字段解析：`package-lock.json` 如何锁定

- 我们以一个 `package-lock.json` 中的片段为例：

```json
"express": {
  "version": "4.18.2",
  "resolved": "https://registry.npmjs.org/express/-/express-4.18.2.tgz",
  "integrity": "sha512-...（一长串哈希值）",
  "dev": false,
  "dependencies": {
    "body-parser": "1.20.1",
    "cookie": "0.5.0"
  },
  "requires": {
    "body-parser": "1.20.1",
    "cookie": "0.5.0"
  }
}
```

- step1. `version`: 精确版本号
  - 即使你在 `package.json` 中写的是 `"express": "^4.18.0"`，
  - npm 安装时会选择一个满足条件的最新版本（如 `4.18.2`），
  - 并在 `package-lock.json` 中**记录这个实际安装的精确版本**。
  - 这就实现了“版本锁定”。
- step2. `resolved`: 下载地址
  - 指明这个包是从哪个 URL 下载的。
  - 防止因 registry 镜像不同或包被删除导致安装失败。
  - 例如：`https://registry.npmjs.org/express/-/express-4.18.2.tgz`
- step3. `integrity`: 内容完整性校验（哈希值）
  - 使用 [Subresource Integrity (SRI)](https://developer.mozilla.org/en-US/docs/Web/Security/Subresource_Integrity) 机制，
  - 存储的是该包压缩文件（`.tgz`）的 **SHA-512 哈希值**。
  - 安装时，npm 会重新计算下载文件的哈希，与 `integrity` 比对。
  - 如果不一致 → 安装失败，防止被篡改或网络错误。
  - 🔒 这是“锁定”的关键：不只是版本号，连内容本身也被验证。
- step4. 依赖树扁平化与嵌套结构
  - `package-lock.json` 会完整记录：
  - 每个包的依赖是谁
  - 是否存在多个版本的同一个包（例如 A 依赖 lodash@4.17.0，B 依赖 lodash@4.17.5）
  - 包的安装路径（嵌套结构）
  - 这样可以确保整个依赖树结构一致。

### 8.2. npm 安装时如何使用 `package-lock.json`

当你运行 `npm install` 时：

- 情况 1：存在 `package-lock.json`
  - npm 会**优先按照 `package-lock.json` 中的 `version` 和 `resolved` 地址**去安装。
  - 不再重新解析版本范围（如 `^` 或 `~`）。
  - 直接下载指定 URL 的包，并校验 `integrity`。
  - ✅ 实现了“可重复构建”。
- 情况 2：不存在 `package-lock.json`
  - npm 只看 `package.json` 中的版本范围。
  - 从 npm registry 获取满足条件的最新版本（可能今天装是 `4.18.2`，明天装变成 `4.18.3`）。
  - 生成新的 `package-lock.json`。

### 8.3. 举个例子：为什么需要锁定？

- 假设你 `package.json` 写：

```json
"dependencies": {
  "lodash": "^4.17.0"
}
```

- 2023 年 1 月：安装时 `^4.17.0` 对应 `4.17.21`，项目正常运行。
- 2023 年 6 月：`lodash@4.17.22` 发布，包含一个 bug。
- 新成员克隆项目，没有 `package-lock.json` → 安装了 `4.17.22` → 项目崩溃！
- 有了 `package-lock.json`，所有人都安装 `4.17.21`，避免问题。

### 8.4. 小结

- `package-lock.json` 实现“锁定”的核心方式是：**记录每一个依赖包的精确版本、下载地址、依赖树结构和完整性校验信息（integrity）**，确保下次安装时完全复现。

| 机制                | 说明                                  |
| ------------------- | ------------------------------------- |
| 📦 `version` 字段   | 记录实际安装的精确版本（如 `4.18.2`） |
| 🔗 `resolved` 字段  | 指定下载地址，避免源差异              |
| 🔐 `integrity` 字段 | 校验包内容完整性，防止篡改            |
| 🌲 完整依赖树       | 记录每个包的依赖关系和嵌套结构        |
| ⚙️ npm 安装策略     | 优先使用 lock 文件，跳过版本解析      |

## 9. 🤔 `npm`、`package.json`、`package-lock.json`、`node_modules` 四者之间的关系是？

- **`package.json` 告诉 npm “想要什么”**
- **`package-lock.json` 告诉 npm “实际装了什么”**
- **npm 负责让两者保持一致，并自动更新 lock 文件**

## 10. 📒 `package-lock.json` 文件结构

- `package-lock.json` 是一个 JSON 格式的文件，其内容通常包括两个主要部分：
  - **顶层字段**
  - **依赖信息**

::: code-group

```json [示例 - 顶层字段]
{
  "name": "example-project",
  "version": "1.0.0",
  "lockfileVersion": 2,
  "requires": true,
  "packages": {},
  "dependencies": {}
}
```

:::

- **`name` 和 `version`**：项目名称和版本号，与 `package.json` 中的一致。
- **`lockfileVersion`**：锁定文件的版本号，用于标识 `package-lock.json` 文件的格式。目前常见的值及其含义如下：
  - **`1`**：旧版格式，默认用于 npm v5 和 v6。主要记录依赖树的层级结构，依赖解析效率较低。
  - **`2`**：新版格式，默认用于 npm v7 和 v8。引入了 `packages` 字段，提供更完整的依赖树信息，显著提升了依赖解析效率。
  - **`3`**：最新格式，默认用于 npm v9 及以上版本。进一步优化性能，特别是支持隐藏锁文件（`node_modules/.package-lock.json`），并包含更多元数据以支持复杂场景。
- **`requires`**：指示是否需要解析依赖关系。
- **`packages`**：记录所有依赖及其子依赖的具体信息（npm v7 及以上引入）。
- **`dependencies`**：记录依赖树的层级结构（npm v6 及以下使用）。

::: warning 建议团队使用的 npm 版本一致

- 虽说 `lockfileVersion: 3` 向后兼容 `lockfileVersion: 2`，但建议团队成员统一使用相同版本的 npm，以避免因格式差异导致的问题。

:::

---

::: code-group

```json [示例 - 依赖信息]
"node_modules/vitepress": {
  "version": "1.6.3",
  "resolved": "https://registry.npmmirror.com/vitepress/-/vitepress-1.6.3.tgz",
  "integrity": "sha512-fCkfdOk8yRZT8GD9BFqusW3+GggWYZ/rYncOfmgcDtP3ualNHCAg+Robxp2/6xfH1WwPHtGpPwv7mbA3qomtBw==",
  "dev": true,
  "license": "MIT",
  "dependencies": {
    "@docsearch/css": "3.8.2",
    "@docsearch/js": "3.8.2",
    "@iconify-json/simple-icons": "^1.2.21",
    "@shikijs/core": "^2.1.0",
    "@shikijs/transformers": "^2.1.0",
    "@shikijs/types": "^2.1.0",
    "@types/markdown-it": "^14.1.2",
    "@vitejs/plugin-vue": "^5.2.1",
    "@vue/devtools-api": "^7.7.0",
    "@vue/shared": "^3.5.13",
    "@vueuse/core": "^12.4.0",
    "@vueuse/integrations": "^12.4.0",
    "focus-trap": "^7.6.4",
    "mark.js": "8.11.1",
    "minisearch": "^7.1.1",
    "shiki": "^2.1.0",
    "vite": "^5.4.14",
    "vue": "^3.5.13"
  },
  "bin": {
    "vitepress": "bin/vitepress.js"
  },
  "peerDependencies": {
    "markdown-it-mathjax3": "^4",
    "postcss": "^8"
  },
  "peerDependenciesMeta": {
    "markdown-it-mathjax3": {
      "optional": true
    },
    "postcss": {
      "optional": true
    }
  }
}
```

:::

- **`version`**：依赖的具体版本号。
- **`resolved`**：依赖的下载地址（通常是 npm 的 CDN 地址）。
- **`integrity`**：依赖的完整性校验值（通常是 SHA-512 哈希值），用于确保依赖未被篡改。
- **`dependencies`**：该依赖的子依赖及其版本信息。
- **`dev`**：布尔值，表示该依赖是否为开发环境依赖。如果为 `true`，则该依赖仅在开发环境中使用，不会被打包到生产环境中。
- **`license`**：该依赖的许可证类型（如 `MIT`、`Apache-2.0` 等），用于声明该包的法律使用许可。
- **`bin`**：定义该依赖提供的可执行文件及其路径。例如，`"vitepress": "bin/vitepress.js"` 表示可以通过命令行运行 `vitepress` 来调用 `bin/vitepress.js` 文件。
- **`peerDependencies`**：同行依赖，列出当前包需要的宿主环境依赖。这些依赖通常由宿主项目提供，而不是由当前包直接安装。例如，`markdown-it-mathjax3` 和 `postcss` 是 VitePress 需要的同行依赖。
- **`peerDependenciesMeta`**：对 `peerDependencies` 的元信息补充说明。例如：
  - 如果某个同行依赖是可选的，则会在 `peerDependenciesMeta` 中标记为 `"optional": true`。
  - 在示例中，`markdown-it-mathjax3` 和 `postcss` 被标记为可选依赖，这意味着即使宿主项目没有安装这些依赖，VitePress 也可以正常工作。
- 通过这些字段，`package-lock.json` 提供了关于依赖的全面信息，包括其来源、版本、许可证、可执行文件以及与其他包的关系等。这些信息不仅有助于确保依赖的一致性，还为开发者提供了清晰的依赖管理视图。
- 补充说明：
  - 依赖信息是 `packages` 或 `dependencies` 字段中的内容，具体是啥，得看你的 npm 版本。
  - ![图 0](https://cdn.jsdelivr.net/gh/Tdahuyou/imgs@main/2025-04-05-18-09-51.png)

## 11. 📒 `package-lock.json` 的自动生成、更新、重置

- **生成**：当你运行 `npm install` 时，如果项目中没有 `package-lock.json` 文件，npm 会自动生成它。
- **更新**：当添加、删除或更新依赖时，`package-lock.json` 会自动更新以反映最新的依赖树。例如：

```bash
npm install express
npm uninstall lodash
npm update axios
```

- **清理和重置**：如果 `package-lock.json` 出现冲突或损坏，可以通过以下命令重新生成：

```bash
rm package-lock.json
npm install
```

## 12. 🔗 References

- https://docs.npmjs.com/cli/v9/configuring-npm/package-lock-json
  - npm docs package-lock.json
  - 这是 npm 的官方对 `package-lock.json` 文件的说明。
